<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="docbook.css" type="text/css"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>Warn-a-Brotha Design</title>
    <subtitle>Computer Science 309 Spring 2002 Term Project</subtitle>
    <releaseinfo>$Header: /cygdrive/c/Users/Chad/Desktop/SourceForge Backup/isugamedev/cvs/brotha/doc/design/design.xml,v 1.44 2002-04-09 05:47:49 nonchocoboy Exp $</releaseinfo>
    <pubdate>$Date: 2002-04-09 05:47:49 $</pubdate>
    <authorgroup>
      <author>
        <firstname>Chad</firstname>
        <surname>Austin</surname>
      </author>
      <author>
        <firstname>Josh</firstname>
        <surname>Carlson</surname>
      </author>
      <author>
        <firstname>Jeremy</firstname>
        <surname>Hanson</surname>
      </author>
      <author>
        <firstname>Chad</firstname>
        <surname>Okere</surname>
      </author>
      <author>
        <firstname>Ben</firstname>
        <surname>Scott</surname>
      </author>
    </authorgroup>
    <address><email>isugamedev-brotha@lists.sourceforge.net</email></address>
    <revhistory>
      <revision>
        <revnumber>1.1</revnumber>
        <date>03 Apr 2002</date>
        <revremark>Created document skeleton.</revremark>
      </revision>
    </revhistory>
  </bookinfo>
  <preface>
    <title>Introduction</title>
    <para><emphasis>Warn-a-Brotha</emphasis> is an online 3D racing game in the spirit of <emphasis>Mario Kart</emphasis> and <emphasis>F-Zero</emphasis>. The game will feature cartoon characters in a multi-player battle cart racing game. Players will be able to compete in combat and racing action against several other networked friends.</para>
    <para>The game will include power-ups, damage meters and an interesting interface. We plan on keeping track of player and gang-related statistics and preferences such as the number of kills they've made, number of times they've died and the number of cars they've trashed. The player will be able to choose one of several characters, each with his or her own look and attitude.</para>
    <para>The <emphasis>Warn-a-Brotha</emphasis> client program will be implemented using OpenGL and C++ while the server will be implemented with portable C++. The clients and server will communicate over the TCP/IP layer. Due to time constraints, we will assume that all computers are on a LAN or other suitably fast connection so that we can generally ignore the lag problems associated with dial-up networked play.</para>
    <para>The underlying database will be implemented using XML tables storing gangs, players, cars and car modifications where each gang can have multiple players, each player can have multiple cars and each car can have multiple modifications.</para>
  </preface>
  <chapter>
    <title>Modules</title>
    <para>At a high level, <emphasis>Warn-a-Brotha</emphasis> can be broken down into several clear modules. This includes Connection Manager, Data/XML, Game Logic, Input, Network, Report Server, Sound, Texture, Threading and UI.</para>
    <section>
      <title>Connection Manager Module</title>
      <para>The Connection Manager module is responsible for handling the sending and receiving of messages from a number of peer connections. Objects of type <classname>Socket</classname> are passed into the module through the <methodname>handleSocket</methodname> method. This method returns a unique connection identification number that will be associated with the <classname>Socket</classname> object. The <methodname>send</methodname> method accepts an object of type <classname>Message</classname> and a connection identification number. The message that is passed in will be sent to the peer connection represented by the connection identification number. The <methodname>readAll</methodname> method will return to the caller a collection of objects of type <classname>Message</classname> and the connection identification number that represents the peer connection from which the <classname>Message</classname> object originated from. The <classname>Message</classname> class provides the abstract implementation for all <classname>Message</classname> objects. Data cannot be sent using the Connection Manager unless the data is represented by an object that implements the <classname>Message</classname> class.</para>
      <para>Internally the Connection Manager module is composed of several classes: <classname>Connection</classname>, <classname>WriteThread</classname> and <classname>ReadThread</classname><classname></classname>. Each <classname>Socket</classname> passed into the module through <methodname>handleSocket</methodname> creates a <classname>Connection</classname> object. This <classname>Connection</classname> object creates a <classname>WriteThread</classname> and a <classname>ReadThread</classname> to handle the actual sending and receiving of data.</para>
      <para>The Connection Manager module depends on the Network module for the actual sending and receiving of bytes across the network, and the Threading module to allow multiple connections, while keeping these connections seperate from the other connections.</para>
      <section>
        <title>Module Interfaces</title>
        <classsynopsis>
          <ooclass>
            <classname>ConnectionManager</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>handleSocket</methodname>
            <methodparam>
              <type>Socket*</type>
              <parameter>sock</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>send</methodname>
            <methodparam>
              <type>Message*</type>
              <parameter>message</parameter>
            </methodparam>
            <methodparam>
              <type>ConnectionID</type>
              <parameter>connID</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>vector&lt;pair&lt;Message*,ConnectionID&gt;&gt; </type>
            <methodname>readAll</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <para>The Connection Manager module has the crucial responsibility of being able to send and receive many messages every frame of the game. The Connection Manager must also gaurantee the delivery of every message and that it will be handled in as little time as possible.</para>
        <section>
          <title>Threads vs. select() or poll()</title>
          <formalpara>
            <title>Alternative 1 - Threads</title>
            <para><variablelist>
                <varlistentry>
                  <term>Pros</term>
                  <listitem>
                    <itemizedlist spacing="compact">
                      <listitem>
                        <para>Easy to implement.</para>
                      </listitem>
                      <listitem>
                        <para>Scheduling CPU time for each connection is handle by the operating system.</para>
                      </listitem>
                    </itemizedlist>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>Cons</term>
                  <listitem>
                    <itemizedlist spacing="compact">
                      <listitem>
                        <para>Doesn't scale well past a few thousand connections.</para>
                      </listitem>
                      <listitem>
                        <para>Added overhead for context switching between threads and the use of mutexes.</para>
                      </listitem>
                    </itemizedlist>
                  </listitem>
                </varlistentry>
              </variablelist></para>
          </formalpara>
          <formalpara>
            <title>Alternative 2- select() or poll()</title>
            <para><variablelist>
                <varlistentry>
                  <term>Pros</term>
                  <listitem>
                    <itemizedlist spacing="compact">
                      <listitem>
                        <para>Reduced overhead for handling multiple connections, no context switches or need for mutexes.</para>
                      </listitem>
                    </itemizedlist>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>Cons</term>
                  <listitem>
                    <itemizedlist spacing="compact">
                      <listitem>
                        <para>More difficult to implement, have to use asynchronous I/O.</para>
                      </listitem>
                      <listitem>
                        <para>Doesn't scale well past a thousand connections.</para>
                      </listitem>
                      <listitem>
                        <para>Must programatically make sure a specific connection doesn't hog the CPU time, as select() and poll() scan connections linearly.</para>
                      </listitem>
                    </itemizedlist>
                  </listitem>
                </varlistentry>
              </variablelist></para>
          </formalpara>
          <formalpara>
            <title>Conclusion</title>
            <para>We decided to choose the threading model because of its ease of implementation, its complete seperation of connections from each other and because we wanted to use the operating system for scheduling of connections' processor usage.</para>
          </formalpara>
        </section>
      </section>
    </section>
    <section>
      <title>Data/XML Module</title>
      <para><classname></classname><classname></classname>The Data/XML module provides access to a persistent, data structure that stores game related data such as cars and players and gangs. One root node <classname>BrothaData</classname>, is used to hold all the data. <classname>BrothaData</classname> provides a method to load and save the data, as well as a convenience function to validate a player based on their password. <classname>BrothaData</classname> also exposes a collection of <classname>Gang</classname> objects, and a collection of <classname>Gang</classname> and <classname>CarType</classname> objects. The <classname>CarType</classname> objects store basic information on a "type" of car, the gangs, basically have a name and a collection of <classname>Player</classname> objects, which in turn hold a name, password and a collection of <classname>Car</classname> objects. Each car has an associated type (from <classname>CarTypes</classname> in the root <classname>BrothaData</classname> node) as well as a collection of <classname>Mod</classname>s. Mods have a "type" and "level" of modification.</para>
      <section>
        <title>Module Interfaces</title>
        <para></para>
        <para>Gang {</para>
        <para>Property string name; </para>
        <para>Property collection&lt;Player&gt; players;</para>
        <para> }</para>
        <para> </para>
        <para>Player {</para>
        <para> String name; </para>
        <para> String password; </para>
        <para> Property collection&lt;Car&gt; cars; </para>
        <para>}</para>
        <para></para>
        <para>CarType {</para>
        <para>string model_file;</para>
        <para>string name; </para>
        <para>} </para>
        <para></para>
        <para>Car {</para>
        <para>CarType cartype; </para>
        <para>Property collection&lt;Mod&gt; mods; </para>
        <para>} </para>
        <para></para>
        <para>ModType { </para>
        <para>// ModType defines actual modification like WeaponModType or something </para>
        <para>// depends on the mod type</para>
        <para>string name; </para>
        <para>string mount_point;</para>
        <para>int amount; } </para>
        <para></para>
        <para>Mod {</para>
        <para>ModType modtype;</para>
        <para>int level;</para>
        <para>}</para>
        <para></para>
        <para>BrothaData {</para>
        <para>Property collection&lt;Gang&gt; gangs; </para>
        <para>boolean validatePlayer(string player, password passwd);</para>
        <para>static BrothaData load(string filename) throws DataException</para>
        <para>Void save(string filename) throws DataException</para>
        <para>} </para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>The BrothaData object needed to be able to store all the information persistantly. Do do that, we decided to use XML and an off the shelf parser. We also decided to use one that supported Xpath and XSL for the report server.</para>
        <section>
          <title>Loading</title>
          <para>One thing we decided to do was to load all the data into memory and create simple wrapper classes around it, rather then using something like SAX and only loading data on demand (and creating wrapper collections and the like). This was done to save time, especially since it won't really end up holding all that much data.</para>
        </section>
      </section>
    </section>
    <section>
      <title>Game Logic Module</title>
      <para>The Game Logic module is responsible for updating the game based on the time passed. It also handles the physics and updates each of the clients information. The Game Logic module manages game specific interactions between object in the world such as cars, buildings and projectiles.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>GameLogic{</para>
        <para> AddPlayer(player)</para>
        <para> RemovePlayer(player)</para>
        <para> AddObject(object)</para>
        <para> Update()</para>
        <para>}</para>
        <para></para>
        <para>Object{</para>
        <para> Prop position</para>
        <para> Prop velocity</para>
        <para> Prop health</para>
        <para> Prop maxhealth</para>
        <para>}</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Input Module</title>
      <para>The Client Input module is responsible for the retrieval of input from the devices. Since the application must run at an approximately consistent frame-rate, the input is polled once every frame by the application. This module has effectively already been implemented using the external GameKernel library developed by Kevin Meinert and Ben Scott. In this library, each device's input is classified as either a digital input or an analog input. Thus inputs can be bound to application specific commands at runtime. GameKernel is also designed to be platform independent making portability as simple as recompiling the application.</para>
      <para>The GameKernel library is broken into three parts - the input manager (<classname>IGameInput</classname>), the system driver (<classname>ISystemDriver</classname>) and the application callbacks (<classname>IGameApp</classname>). The <classname>IGameKernel</classname> interface is the facade on top of all of these subsystems through which the application is managed by the GameKernel library.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Network Module</title>
      <para>The network module is responsible for creating sockets and server sockets. It also provides stream classes which simplify access to stream-like objects such as network connections and files. It is built on top of NSPR, a portable system abstraction library provided by mozilla.org.</para>
      <section>
        <title>Socket Subsystem</title>
        <para>The socket subsystem consists of two classes: <classname>Socket</classname> and <classname>ServerSocket</classname>. <classname>ServerSocket</classname> listens on a network port and returns new <classname>Socket</classname> objects when connections are made. <classname>Socket</classname> objects provide methods for reading from, writing to, and closing the socket.</para>
        <para>Sockets also have associated <classname>SocketInputStream</classname> and <classname>SocketOutputStream</classname> objects. See the Stream Subsystem documentation for more details.</para>
      </section>
      <section>
        <title>Stream Subsystem</title>
        <para>The stream subsystem provides objects that represent streams of bytes. Specifically, streams are split into two concepts: InputStreams and OutputStreams. InputStreams have a single <methodname>read</methodname> method and OutputStreams have a single <methodname>write</methodname> method. For example, Sockets have associated <classname>InputStream</classname> and <classname>OutputStream</classname> objects which facilitate reading from and writing to the network connection. The <classname>ByteBuffer</classname> class implements both <classname>InputStream</classname> and <classname>OutputStream</classname> and represents a growable array of bytes.</para>
      </section>
      <section>
        <title>Serialization Subsystem</title>
        <para>The serialization aspect of the network module is responsible for converting objects into streams of bytes and reconstructing the original objects from the stored bytes. It provides a set of operator overloads (mimicking standard C++ iostreams) which simplify writing objects to and reading objects from OutputStreams and InputStreams, respectively.</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>class Socket {</para>
        <para> Socket(string hostname, int port);</para>
        <para> int write(buffer, size);</para>
        <para> void read(buffer, size);</para>
        <para> void close();</para>
        <para> InputStream getInputStream();</para>
        <para> OutputStream getOutputStream();</para>
        <para>}</para>
        <para>class ServerSocket {</para>
        <para> ServerSocket(int port);</para>
        <para> Socket accept();</para>
        <para>}</para>
        <para>interface InputStream {</para>
        <para> void read(buffer, size);</para>
        <para>}</para>
        <para>interface OutputStream {</para>
        <para> void write(buffer, size);</para>
        <para>}</para>
        <para>class ByteBuffer implements InputStream, OutputStream;</para>
        <para></para>
        <para>template&lt;typename T&gt; OutputStream&amp; operator&lt;&lt;(OutputStream&amp; os, T value);</para>
        <para>template&lt;typename T&gt; InputStream&amp; operator&gt;&gt;(InputStream&amp; os, T&amp; value);</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>Networking code is often the hardest to design in nontrivial systems. One decision we had to make was whether socket reads and writes were blocking or nonblocking. Blocking socket calls do not return until the I/O operation has completed. Nonblocking calls simply do as much as work as they can and return the number of bytes they read or wrote.</para>
        <section>
          <title>Blocking vs. Nonblocking I/O</title>
          <para>Blocking I/O</para>
          <para>Pros</para>
          <para>- easy to implement and understand</para>
          <para>Cons</para>
          <para>- requires threads for interactivity</para>
          <para></para>
          <para>Nonblocking I/O</para>
          <para>Pros</para>
          <para>- does not require threading or involve synchronization issues</para>
          <para>Cons</para>
          <para>- requires a lot of complex code (involving many loops and state machines) for conceptually simple operations</para>
          <para></para>
          <para>Since blocking I/O is so much simpler to use than nonblocking I/O, we chose to use it for all game message passing. However, since blocking I/O requires knowing how much data you need to read or write at a time, we cannot use it for the http server. Therefore, the socket objects will also support a nonblocking mode.</para>
        </section>
      </section>
    </section>
    <section>
      <title>Report Server Module</title>
      <para>The Report Server module is responsible for generating dynamic reports requested by HTTP 1.0 standards complient clients. The reports will be generated based on data gathered from the Data/XML module. These reports will be formatted to comply with the specifications for the HyperText Markup Language. This module depends on the Data/XML module for the gathering of data and the Network module for the use of a <classname>ServerSocket</classname> to accept sockets and a <classname>Socket</classname> for the transmitting of data.</para>
      <section>
        <title>Module Interfaces</title>
        <para>ReportServer.Start():bool </para>
        <para>ReportServer.Stop():void </para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>One of the design decisions made was to use "high tech" XML processing systems to create and format the data, this means using things like XSL and XPath to select the data. Rather then writing a bunch of custom routines to generate the HTML, we'll use a style sheet to create it directly from XML, and use XPath to select arbitrary data from the tree.</para>
      </section>
    </section>
    <section>
      <title>Sound Module</title>
      <para>The sound module is responsible for managing background music and sound effects within the game. Brotha uses <emphasis>Audiere</emphasis>, an external audio library independently developed by Chad Austin, for reading and playing streams of audio. The sound module consists of two subsystems: the background music <classname>Jukebox</classname> object and the <classname>SoundEffectManager</classname> object.</para>
      <section>
        <title>Jukebox Subsystem</title>
        <para>The <classname>Jukebox</classname> is responsible for maintaining a list of background music <classname>Track</classname>s. It provides functionality for adding <classname>Track</classname>s, removing <classname>Track</classname>s, starting playback, stopping or pausing playback and changing the background music volume. It also provides functionality for getting the current track name and how long it has been playing. Since Audiere files are streamed from disk, the <classname>Jukebox</classname> does not have to load entire songs into memory.</para>
      </section>
      <section>
        <title>Sound Effect Manager Subsystem</title>
        <para>The sound effect manager is responsible for playing sound effects, which are referred to by name. The <classname>SoundEffectManager</classname> has one method, <methodname>trigger</methodname>, which loads a sound effect if it hasn't already been loaded and plays it at a specified volume. Since sound effects can be played often and at unpredictable times, the sound effect manager should keep them in memory to prevent unpredictable latency.</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <figure>
          <title>Sound Module Interface Specification</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="figures/sound_classes.png" format="PNG" scalefit="1"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>The interface for the Sound module consists of the <classname>Jukebox</classname> and <classname>SoundEffectManager</classname> classes.</para>
        <classsynopsis>
          <ooclass>
            <classname>Jukebox</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>addTrack</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>removeTrack</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>unsigned int</type>
            <methodname>getNumTracks</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>start</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>stop</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>SoundEffectManager</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>trigger</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which COTS audio library should we use?</para>
            </question>
            <answer>
              <para>From the outside, the sound module directly satisfies the audio needs of the application. However, it can be implemented using one of several audio decoding and playback libraries.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>Audiere</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Open source.</para>
                          </listitem>
                          <listitem>
                            <para>Developed by a member of the Brotha team.</para>
                          </listitem>
                          <listitem>
                            <para>Very simple and straightforward API.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Not as mature as some other libraries.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 1 - <emphasis>FMOD</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Mature and stable library</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Needlessly complex API</para>
                          </listitem>
                          <listitem>
                            <para>Closed source</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>We chose Audiere for a couple reasons. The members of the team are more familiar with it than FMOD. Since Audiere is open source, we can update it to include any functionality we need.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
    <section>
      <title>Texture Module</title>
      <para>The texture module is responsible for loading image files from the disk and creating OpenGL texture objects out of them. It uses the third-party <emphasis>Corona</emphasis> image library (externally developed by Chad Austin). The texture module has two object types: one <classname>TextureManager</classname> and several <classname>Texture</classname> objects.</para>
      <para>The <classname>TextureManager</classname>, given the name of a <classname>Texture</classname>, will load the texture from disk, possibly process the image until it is in a format suitable for OpenGL, and create a new <classname>Texture</classname> object representing that texture. The <classname>TextureManager</classname> remembers and caches loaded textures so that it never loads a texture twice. </para>
      <para><classname>Texture</classname> objects provide a <methodname>bind</methodname> method which calls <methodname>glBindTexture</methodname>, changing OpenGL's current texture. It also provides a mechanism for changing texture parameters, such as whether to use <constant>NEAREST</constant> or <constant>LINEAR</constant> texel interpolation.</para>
      <section>
        <title>Module Interfaces</title>
        <classsynopsis>
          <ooclass>
            <classname>TextureManager</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>Texture</type>
            <methodname>getTexture</methodname>
            <methodparam>
              <type>string</type>
              <parameter>name</parameter>
            </methodparam>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Texture</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>void</type>
            <methodname>setParameter</methodname>
            <methodparam>
              <type>string</type>
              <parameter>parameter</parameter>
            </methodparam>
            <methodparam>
              <type>string</type>
              <parameter>value</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>void</type>
            <methodname>bind</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <para>Like the sound module, the texture module sits on top of low-level libraries and provides a convenient mechanism for accessing textures within the context of the Warn-a-Brotha game. Since the interface to the module is so general, it can be implemented internally in many different ways.</para>
        <section>
          <title>Corona vs. Other Image Libraries</title>
          <para>Corona</para>
          <para>Pros</para>
          <para>- portable</para>
          <para>- very easy to install and use</para>
          <para>- developed by a member of the team</para>
          <para>Cons</para>
          <para>- not as mature as it could be</para>
          <para></para>
          <para>Other Image Libraries (FreeImage, DevIL, SDL_Image)</para>
          <para>Pros</para>
          <para>- APIs are usually more stable</para>
          <para>- more widely used</para>
          <para>Cons</para>
          <para>- often not portable</para>
          <para>- difficult to interact with</para>
          <para>- difficult to install</para>
          <para></para>
          <para>Because Corona is easier to use and the developers are more familiar with it, we chose to implement the texture subsystem on top of it. We don't plan to use file formats that Corona does not support.</para>
        </section>
        <section>
          <title>Texture Caching Policy</title>
          <para></para>
          <para>The texture manager can cache loaded textures in many ways. It could remember the most recently used textures and not load them twice. It could also cache every texture so that an image is never loaded from disk more than once. It could even not cache them at all.</para>
          <para></para>
          <para>We decided the ease of implementation vs. performance traceoff is optimal in the case where we cache everything. Therefore, that is what we will implement.</para>
        </section>
      </section>
    </section>
    <section>
      <title>Thread Module</title>
      <para>The thread module provides a suite of utility classes for creating threads and synchronizing them. It is built on top of NSPR (Netscape Portable Runtime) which is a portable system abstraction layer for C provided by mozilla.org. It consists of several classes: a base <classname>Thread</classname> class, a <classname>Lockable</classname> interface, a <classname>Mutex</classname> implementation of the <classname>Lockable</classname> interface, a <classname>ConditionVariable</classname> class, and a <classname>Synchronized</classname> mix-in class which provides functionality similar to Java's synchronized method semantics.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>UI Module</title>
      <para>The UI module is responsible for the creation and management of GUI widget elements such as windows, buttons and such. For this module, we will rely on a COTS library suitable for our application.</para>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which COTS library should we use for the GUI implementation?</para>
            </question>
            <answer>
              <para>The client application is being developed using OpenGL. As such normal Win32 controls may not be used within the windows with the OpenGL rendering context. We need to depend on some external library that can render controls within using OpenGL commands.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>GLUI</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Easy to use.</para>
                          </listitem>
                          <listitem>
                            <para>It's been around a while and is relatively mature.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Won't integrate well with <emphasis>GameKernel</emphasis>.</para>
                          </listitem>
                          <listitem>
                            <para>Difficult to create controls in the master window. Often times, a separate window is required to put the control in.</para>
                          </listitem>
                          <listitem>
                            <para>Control rendering is not customizable.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2- <emphasis>phui</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Easy to use.</para>
                          </listitem>
                          <listitem>
                            <para>Allows customization of the rendering of controls.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Is not mature or stable.</para>
                          </listitem>
                          <listitem>
                            <para>May integrate with <emphasis>GameKernel</emphasis> to some limited extent.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>We're stuck with <emphasis>GameKernel</emphasis> to provide our applications input. Thus the choice clearly points towards using <emphasis>phui</emphasis>. We have to gamble that phui developers can make it stable in the next couple of weeks.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
  </chapter>
  <chapter>
    <title>Putting It All Together</title>
    <para>Since <emphasis>Warn-a-Brotha</emphasis> has an overall client/server design, the project can be split into two distinctly seperate applications that use the modules differently.</para>
    <section>
      <title>The Server Application</title>
      <figure>
        <title>Components used by the Server Application</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="figures/server_components.png" format="PNG" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The server is the main workhorse, responsible for managing multiple client connections and their requests, updating the state of the game on a regular basis and sending messages to connected clients with the updates on the state of the game. The server is also responsible for storing gang, player, car, and car modification specific information, providing this information to the clients, and generating reports on this information.</para>
    </section>
    <section>
      <title>The Client Application</title>
      <figure>
        <title>Components Used by the Client Application</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="figures/client_components.png" format="PNG" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The client application is simply the glue that binds the various modules it requires - namely Connection Manager, Input, Sound, Texture and UI. It is really just a dumb display which allows the user to connect to the server. Once connected, it processes input from the attached and configured devices and which device inputs are triggered, forwards the corresponding request to the server. The client also provides a visual view onto the game world based on the update data received from the server.</para>
    </section>
  </chapter>
  <chapter>
    <title>Traceability Matrix</title>
    <para>probably figure out how to create a table or else stuff a pic in here</para>
  </chapter>
  <appendix>
    <title>External Dependencies</title>
    <variablelist>
      <varlistentry>
        <term><emphasis>Audiere</emphasis></term>
        <listitem>
          <para>Audiere is a high-level audio API, somewhat analogous to FMOD. Built on top of Acoustique, it supports MP3, Ogg Vorbis, uncompressed WAV, IT, XM, S3M and MOD. It can use DirectSound 8, DirectSound 3 or arbitrary DLLs for audio output. In Linux, it can use OSS or OpenAL. At the moment, Audiere only works under Win32 and Linux. It is licensed under the LGPL.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>Corona</emphasis></term>
        <listitem>
          <para>Corona is a high-level, portable I/O library usable from C++. It can read PNG, JPEG, PCX and BMP images, and can write PNGs. It's licensed under the zlib license.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>Game Kernel</emphasis></term>
        <listitem>
          <para>GameKernel is a flexible, open-source platform for running games being developed by members of the Iowa State University Game Developers Club. Designed with pluggable DLL drivers, GameKernel can currently operate using GLUT or SDL. It is supported on Windows, Linux and IRIX. Game Kernel is licensed under the LGPL.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>phui</emphasis></term>
        <listitem>
          <para>Phui is a "phlexible user interface" for OpenGL based applications. Developed by members of the Game Developers Club at IowaState University, phui is designed to allow for the large amount of control in the rendering of widgets that game developers demand.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>NSPR</emphasis></term>
        <listitem>
          <para>Netscape Portable Runtime (NSPR) provides a platform-neutral API for system level and libc like functions. The API is used in the Mozilla client, many of Netscape/AOL/iPlanet's and other software offerings.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </appendix>
</book>
