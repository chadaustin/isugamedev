<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="file://localhost/home9/users/aegisk/isugamedev/brotha/doc/design/docbook.css" type="text/css"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>Warn-a-Brotha Design</title>
    <subtitle>Computer Science 309 Spring 2002 Term Project</subtitle>
    <releaseinfo>$Header: /cygdrive/c/Users/Chad/Desktop/SourceForge Backup/isugamedev/cvs/brotha/doc/design/design.xml,v 1.9 2002-04-08 06:14:05 aegis Exp $</releaseinfo>
    <pubdate>$Date: 2002-04-08 06:14:05 $</pubdate>
    <authorgroup>
      <author>
        <firstname>Chad</firstname>
        <surname>Austin</surname>
      </author>
      <author>
        <firstname>Josh</firstname>
        <surname>Carlson</surname>
      </author>
      <author>
        <firstname>Jeremy</firstname>
        <surname>Hanson</surname>
      </author>
      <author>
        <firstname>Chad</firstname>
        <surname>Okere</surname>
      </author>
      <author>
        <firstname>Ben</firstname>
        <surname>Scott</surname>
      </author>
    </authorgroup>
    <address><email>isugamedev-brotha@lists.sourceforge.net</email></address>
    <revhistory>
      <revision>
        <revnumber>1.1</revnumber>
        <date>03 Apr 2002</date>
        <revremark>Created document skeleton.</revremark>
      </revision>
    </revhistory>
  </bookinfo>
  <preface>
    <title>Introduction</title>
    <para><emphasis>Warn-a-Brotha</emphasis> is an online 3D racing game in the spirit of <emphasis>Mario Kart</emphasis> and <emphasis>F-Zero</emphasis>. The game will feature cartoon characters in a multi-player battle cart racing game. Players will be able to compete in combat and racing action against several other networked friends.</para>
    <para>The game will include power-ups, damage meters and an interesting interface. We plan on keeping track of player and gang-related statistics and preferences such as the number of kills they've made, number of times they've died and the number of cars they've trashed. The player will be able to choose one of several characters, each with his or her own look and attitude.</para>
    <para>The <emphasis>Warn-a-Brotha</emphasis> client program will be implemented using OpenGL and C++ while the server will be implemented with portable C++. The clients and server will communicate over the TCP/IP layer. Due to time constraints, we will assume that all computers are on a LAN or other suitably fast connection so that we can generally ignore the lag problems associated with dial-up networked play.</para>
    <para>The underlying database will be implemented using XML tables storing gangs, players, cars and car modifications where each gang can have multiple players, each player can have multiple cars and each car can have multiple modifications.</para>
  </preface>
  <chapter>
    <title>Modules</title>
    <para>At a high level, <emphasis>Warn-a-Brotha</emphasis> can be broken down into several clear modules. This includes Connection Manager, Data/XML, Game Logic, Input, Network, Report Server, Sound, Texture, Threading and UI.</para>
    <section>
      <title>Connection Manager Module</title>
      <para>Description of what this module does here ...</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Data/XML Module</title>
      <para>Description of what this module does here ...</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Game Logic Module</title>
      <para>Description of what this module does here ...</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Input Module</title>
      <para>The Client Input module is responsible for the retrieval of input from the devices. Since the application must run at an approximately consistent frame-rate, the input is polled once every frame by the application. This module has effectively already been implemented using the external GameKernel library developed by Kevin Meinert and Ben Scott. In this library, each device's input is classified as either a digital input or an analog input. Thus inputs can be bound to application specific commands at runtime. GameKernel is also designed to be platform independent making portability as simple as recompiling the application.</para>
      <para>The GameKernel library is broken into three parts - the input manager (<classname>IGameInput</classname>), the system driver (<classname>ISystemDriver</classname>) and the application callbacks (<classname>IGameApp</classname>). The <classname>IGameKernel</classname> interface is the facade on top of all of these subsystems through which the application is managed by the GameKernel library.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Network Module</title>
      <para>The network module is responsible for creating sockets and server sockets. It also provides stream classes which simplify access to stream-like objects such as network connections and files. It is built on top of NSPR, a portable system abstraction library provided by mozilla.org.</para>
      <section>
        <title>Socket Subsystem</title>
        <para>The socket subsystem consists of two classes: Socket and ServerSocket. ServerSocket listens on a network port and returns new Socket objects when connections are made. Socket objects provide methods for reading from, writing to, and closing the socket.</para>
        <para>Sockets also have associated SocketInputStream and SocketOutputStream objects. See the Stream Subsystem documentation for more details.</para>
      </section>
      <section>
        <title>Stream Subsystem</title>
        <para>The stream subsystem provides objects that represent streams of bytes. Specifically, streams are split into two concepts: InputStreams and OutputStreams. InputStreams have a single <emphasis>read</emphasis> method and OutputStreams have a single <emphasis>write</emphasis> method. For example, Sockets have associated InputStream and OutputStream objects which facilitate reading from and writing to the network connection. The ByteBuffer class implements both InputStream and OutputStream and represents a growable array fo bytes.</para>
      </section>
      <section>
        <title>Serialization Subsystem</title>
        <para>The serialization aspect of the network module is responsible for converting objects into streams of bytes and reconstructing the original objects from the stored bytes. It provides a set of operator overloads (mimicking standard C++ iostreams) which simplify writing objects to and reading objects from OutputStreams and InputStreams, respectively.</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Report Server Module</title>
      <para>Description of what this module does here ...</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Sound Module</title>
      <para>The sound module is responsible for managing background music and sound effects within the game. Brotha uses Audiere, an external audio library independently developed by Chad Austin, for reading and playing streams of audio. The sound module consists of two concepts: the background music <emphasis>Jukebox</emphasis> object and the <emphasis>SoundEffectManager</emphasis> object.</para>
      <para>The jukebox is responsible for maintaining a list of background music tracks. It provides functionality for adding tracks, removing tracks, starting playback, stopping or pausing playback, and changing the background music volume. It also provides functionality for getting the current track name and how long it's been playing. Since Audiere files are streamed from disk, the jukebox does not have to load entire songs into memory.</para>
      <para>The sound effect manager is responsible for playing sound effects, which are referred to by name. The sound effect manager has one method, Trigger, which loads a sound effect if it hasn't already been loaded and plays it at a specified volume. Since sound effects can be played often and at unpredictable times, the sound effect manager should keep them in memory to prevent unpredictable latency.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>The interface for the Sound module consists of the <classname>Jukebox</classname> and <classname>SoundEffectManager</classname> classes.</para>
        <section>
          <title><classname>Jukebox</classname></title>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>addTrack</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>removeTrack</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>unsigned int</type>
            <methodname>getNumTracks</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>start</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>stop</methodname>
            <void/>
          </methodsynopsis>
        </section>
        <section>
          <title><classname>SoundEffectManager</classname></title>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>trigger</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
        </section>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Texture Module</title>
      <para>The texture module is responsible for loading image files from the disk and creating OpenGL texture objects out of them. It uses the third-party Corona image library (externally developed by Chad Austin). The texture module has two object types: one TextureManager and several Texture objects.</para>
      <para>The texture manager, given the name of a texture, will load the texture from disk, possibly process the image until it's in a format suitable for OpenGL, and create a new Texture object representing that texture. The TextureManager remembers and caches loaded textures so that it never loads a texture twice. </para>
      <para>Texture objects provide a bind method which calls <emphasis>glBindTexture</emphasis>, changing OpenGL's current texture. It also provides a mechanism for changing texture parameters, such as whether to use NEAREST or LINEAR texel interpolation.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Thread Module</title>
      <para>The thread module provides a suite of utility classes for creating threads and synchronizing them. It is built on top of NSPR (Netscape Portable Runtime) which is a portable system abstraction layer for C provided by mozilla.org. It consists of several classes: a base Thread class, a Lockable interface, a Mutex implementation of the Lockable interface, a ConditionVariable class, and a Synchronized mix-in class which provides functionality similar to Java's synchronized method semantics.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>UI Module</title>
      <para>Description of what this module does here ...</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
  </chapter>
  <chapter>
    <title>Putting It All Together</title>
    <para>Since <emphasis>Warn-a-Brotha</emphasis> has an overall client/server design, the project can be split into two distinctly seperate applications that use the modules differently. The server is the main workhorse, responsible for managing multiple client connections and their requests, updating the state of the game on a regular basis and sending messages to connected clients with updates on the state of the game. The client on the other hand is really just a relatively dumb display which allows the user to connect to the server. Once connected, it processes input from the attached devices and when device inputs are triggered, forwards the corresponding request to the server. The client also provides a visual view onto the game world based on the update data received from the server.</para>
    <section>
      <title>The Server Application</title>
      <para>blah blah. blah blah blah blah.</para>
    </section>
    <section>
      <title>The Client Application</title>
      <para>blah blah. blah blah blah blah.</para>
    </section>
  </chapter>
  <chapter>
    <title>Traceability Matrix</title>
    <para>probably figure out how to create a table or else stuff a pic in here</para>
  </chapter>
</book>
