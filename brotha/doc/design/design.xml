<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="http://isugamedev.sourceforge.net/brotha/docbook.css" type="text/css"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>Warn-a-Brotha Design</title>
    <subtitle>Computer Science 309 Spring 2002 Term Project</subtitle>
    <releaseinfo>$Header: /cygdrive/c/Users/Chad/Desktop/SourceForge Backup/isugamedev/cvs/brotha/doc/design/design.xml,v 1.15 2002-04-08 10:20:52 nonchocoboy Exp $</releaseinfo>
    <pubdate>$Date: 2002-04-08 10:20:52 $</pubdate>
    <authorgroup>
      <author>
        <firstname>Chad</firstname>
        <surname>Austin</surname>
      </author>
      <author>
        <firstname>Josh</firstname>
        <surname>Carlson</surname>
      </author>
      <author>
        <firstname>Jeremy</firstname>
        <surname>Hanson</surname>
      </author>
      <author>
        <firstname>Chad</firstname>
        <surname>Okere</surname>
      </author>
      <author>
        <firstname>Ben</firstname>
        <surname>Scott</surname>
      </author>
    </authorgroup>
    <address><email>isugamedev-brotha@lists.sourceforge.net</email></address>
    <revhistory>
      <revision>
        <revnumber>1.1</revnumber>
        <date>03 Apr 2002</date>
        <revremark>Created document skeleton.</revremark>
      </revision>
    </revhistory>
  </bookinfo>
  <preface>
    <title>Introduction</title>
    <para><emphasis>Warn-a-Brotha</emphasis> is an online 3D racing game in the spirit of <emphasis>Mario Kart</emphasis> and <emphasis>F-Zero</emphasis>. The game will feature cartoon characters in a multi-player battle cart racing game. Players will be able to compete in combat and racing action against several other networked friends.</para>
    <para>The game will include power-ups, damage meters and an interesting interface. We plan on keeping track of player and gang-related statistics and preferences such as the number of kills they've made, number of times they've died and the number of cars they've trashed. The player will be able to choose one of several characters, each with his or her own look and attitude.</para>
    <para>The <emphasis>Warn-a-Brotha</emphasis> client program will be implemented using OpenGL and C++ while the server will be implemented with portable C++. The clients and server will communicate over the TCP/IP layer. Due to time constraints, we will assume that all computers are on a LAN or other suitably fast connection so that we can generally ignore the lag problems associated with dial-up networked play.</para>
    <para>The underlying database will be implemented using XML tables storing gangs, players, cars and car modifications where each gang can have multiple players, each player can have multiple cars and each car can have multiple modifications.</para>
  </preface>
  <chapter>
    <title>Modules</title>
    <para>At a high level, <emphasis>Warn-a-Brotha</emphasis> can be broken down into several clear modules. This includes Connection Manager, Data/XML, Game Logic, Input, Network, Report Server, Sound, Texture, Threading and UI.</para>
    <section>
      <title>Connection Manager Module</title>
      <para>Description of what this module does here ...</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Data/XML Module</title>
      <para>Description of what this module does here ...</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Game Logic Module</title>
      <para>Description of what this module does here ...</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Input Module</title>
      <para>The Client Input module is responsible for the retrieval of input from the devices. Since the application must run at an approximately consistent frame-rate, the input is polled once every frame by the application. This module has effectively already been implemented using the external GameKernel library developed by Kevin Meinert and Ben Scott. In this library, each device's input is classified as either a digital input or an analog input. Thus inputs can be bound to application specific commands at runtime. GameKernel is also designed to be platform independent making portability as simple as recompiling the application.</para>
      <para>The GameKernel library is broken into three parts - the input manager (<classname>IGameInput</classname>), the system driver (<classname>ISystemDriver</classname>) and the application callbacks (<classname>IGameApp</classname>). The <classname>IGameKernel</classname> interface is the facade on top of all of these subsystems through which the application is managed by the GameKernel library.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Network Module</title>
      <para>The network module is responsible for creating sockets and server sockets. It also provides stream classes which simplify access to stream-like objects such as network connections and files. It is built on top of NSPR, a portable system abstraction library provided by mozilla.org.</para>
      <section>
        <title>Socket Subsystem</title>
        <para>The socket subsystem consists of two classes: <classname>Socket</classname> and <classname>ServerSocket</classname>. <classname>ServerSocket</classname> listens on a network port and returns new <classname>Socket</classname> objects when connections are made. <classname>Socket</classname> objects provide methods for reading from, writing to, and closing the socket.</para>
        <para>Sockets also have associated <classname>SocketInputStream</classname> and <classname>SocketOutputStream</classname> objects. See the Stream Subsystem documentation for more details.</para>
      </section>
      <section>
        <title>Stream Subsystem</title>
        <para>The stream subsystem provides objects that represent streams of bytes. Specifically, streams are split into two concepts: InputStreams and OutputStreams. InputStreams have a single <methodname>read</methodname> method and OutputStreams have a single <methodname>write</methodname> method. For example, Sockets have associated <classname>InputStream</classname> and <classname>OutputStream</classname> objects which facilitate reading from and writing to the network connection. The <classname>ByteBuffer</classname> class implements both <classname>InputStream</classname> and <classname>OutputStream</classname> and represents a growable array of bytes.</para>
      </section>
      <section>
        <title>Serialization Subsystem</title>
        <para>The serialization aspect of the network module is responsible for converting objects into streams of bytes and reconstructing the original objects from the stored bytes. It provides a set of operator overloads (mimicking standard C++ iostreams) which simplify writing objects to and reading objects from OutputStreams and InputStreams, respectively.</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Report Server Module</title>
      <para>Description of what this module does here ...</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Sound Module</title>
      <para>The sound module is responsible for managing background music and sound effects within the game. Brotha uses <emphasis>Audiere</emphasis>, an external audio library independently developed by Chad Austin, for reading and playing streams of audio. The sound module consists of two concepts: the background music <classname>Jukebox</classname> object and the <classname>SoundEffectManager</classname> object.</para>
      <para>The jukebox is responsible for maintaining a list of background music tracks. It provides functionality for adding tracks, removing tracks, starting playback, stopping or pausing playback, and changing the background music volume. It also provides functionality for getting the current track name and how long it's been playing. Since Audiere files are streamed from disk, the jukebox does not have to load entire songs into memory.</para>
      <para>The sound effect manager is responsible for playing sound effects, which are referred to by name. The <classname>SoundEffectManager</classname> has one method, <methodname>trigger</methodname>, which loads a sound effect if it hasn't already been loaded and plays it at a specified volume. Since sound effects can be played often and at unpredictable times, the sound effect manager should keep them in memory to prevent unpredictable latency.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>The interface for the Sound module consists of the <classname>Jukebox</classname> and <classname>SoundEffectManager</classname> classes.</para>
        <classsynopsis>
          <ooclass>
            <classname>Jukebox</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>addTrack</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>removeTrack</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>unsigned int</type>
            <methodname>getNumTracks</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>start</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>stop</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>SoundEffectManager</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>trigger</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Texture Module</title>
      <para>The texture module is responsible for loading image files from the disk and creating OpenGL texture objects out of them. It uses the third-party <emphasis>Corona</emphasis> image library (externally developed by Chad Austin). The texture module has two object types: one <classname>TextureManager</classname> and several <classname>Texture</classname> objects.</para>
      <para>The <classname>TextureManager</classname>, given the name of a <classname>Texture</classname>, will load the texture from disk, possibly process the image until it is in a format suitable for OpenGL, and create a new <classname>Texture</classname> object representing that texture. The <classname>TextureManager</classname> remembers and caches loaded textures so that it never loads a texture twice. </para>
      <para><classname>Texture</classname> objects provide a <methodname>bind</methodname> method which calls <methodname>glBindTexture</methodname>, changing OpenGL's current texture. It also provides a mechanism for changing texture parameters, such as whether to use <constant>NEAREST</constant> or <constant>LINEAR</constant> texel interpolation.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Thread Module</title>
      <para>The thread module provides a suite of utility classes for creating threads and synchronizing them. It is built on top of NSPR (Netscape Portable Runtime) which is a portable system abstraction layer for C provided by mozilla.org. It consists of several classes: a base <classname>Thread</classname> class, a <classname>Lockable</classname> interface, a <classname>Mutex</classname> implementation of the <classname>Lockable</classname> interface, a <classname>ConditionVariable</classname> class, and a <classname>Synchronized</classname> mix-in class which provides functionality similar to Java's synchronized method semantics.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <para>blah blah</para>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>UI Module</title>
      <para>The UI module is responsible for the creation and management of GUI widget elements such as windows, buttons and such. For this module, we will rely on a COTS library suitable for our application.</para>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which COTS library should we use for the GUI implementation?</para>
            </question>
            <answer>
              <para>The client application is being developed using OpenGL. As such normal Win32 controls may not be used within the windows with the OpenGL rendering context. We need to depend on some external library that can render controls within using OpenGL commands.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>GLUI</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist>
                          <listitem>
                            <para>Easy to use.</para>
                          </listitem>
                          <listitem>
                            <para>It's been around a while and is relatively mature.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist>
                          <listitem>
                            <para>Won't integrate well with <emphasis>GameKernel</emphasis>.</para>
                          </listitem>
                          <listitem>
                            <para>Difficult to create controls in the master window. Often times, a separate window is required to put the control in.</para>
                          </listitem>
                          <listitem>
                            <para>Control rendering is not customizable.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2- <emphasis>phui</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist>
                          <listitem>
                            <para>Easy to use.</para>
                          </listitem>
                          <listitem>
                            <para>Allows customization of the rendering of controls.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist>
                          <listitem>
                            <para>Is not mature or stable.</para>
                          </listitem>
                          <listitem>
                            <para>May integrate with <emphasis>GameKernel</emphasis> to some limited extent.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>We're stuck with <emphasis>GameKernel</emphasis> to provide our applications input. Thus the choice clearly points towards using <emphasis>phui</emphasis>. We have to gamble that phui developers can make it stable in the next couple of weeks.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
  </chapter>
  <chapter>
    <title>Putting It All Together</title>
    <para>Since <emphasis>Warn-a-Brotha</emphasis> has an overall client/server design, the project can be split into two distinctly seperate applications that use the modules differently.</para>
    <section>
      <title>The Server Application</title>
      <para>The server is the main workhorse, responsible for managing multiple client connections and their requests, updating the state of the game on a regular basis and sending message to connected clients with the updates on the state of the game.</para>
    </section>
    <section>
      <title>The Client Application</title>
      <para>The client application is simply the glue that binds the various modules it requires - namely Connection Manager, Input, Sound, Texture and UI. It is really just a dumb display which allows the user to connect to the server. Once connected, it processes input from the attached and configured devices and which device inputs are triggered, forwards the corresponding request to the server. The client also provides a visual view onto the game world based on the update data received from the server.</para>
    </section>
  </chapter>
  <chapter>
    <title>Traceability Matrix</title>
    <para>probably figure out how to create a table or else stuff a pic in here</para>
  </chapter>
  <appendix>
    <title>External Dependencies</title>
    <variablelist>
      <varlistentry>
        <term><emphasis>Audiere</emphasis></term>
        <listitem>
          <para>Audiere is a high-level audio API, somewhat analogous to FMOD. Built on top of Acoustique, it supports MP3, Ogg Vorbis, uncompressed WAV, IT, XM, S3M and MOD. It can use DirectSound 8, DirectSound 3 or arbitrary DLLs for audio output. In Linux, it can use OSS or OpenAL. At the moment, Audiere only works under Win32 and Linux. It is licensed under the LGPL.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>Corona</emphasis></term>
        <listitem>
          <para>Corona is a high-level, portable I/O library usable from C++. It can read PNG, JPEG, PCX and BMP images, and can write PNGs. It's licensed under the zlib license.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>Game Kernel</emphasis></term>
        <listitem>
          <para>GameKernel is a flexible, open-source platform for running games being developed by members of the Iowa State University Game Developers Club. Designed with pluggable DLL drivers, GameKernel can currently operate using GLUT or SDL. It is supported on Windows, Linux and IRIX. Game Kernel is licensed under the LGPL.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>phui</emphasis></term>
        <listitem>
          <para>Phui is a "phlexible user interface" for OpenGL based applications. Developed by members of the Game Developers Club at IowaState University, phui is designed to allow for the large amount of control in the rendering of widgets that game developers demand.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>NSPR</emphasis></term>
        <listitem>
          <para>Netscape Portable Runtime (NSPR) provides a platform-neutral API for system level and libc like functions. The API is used in the Mozilla client, many of Netscape/AOL/iPlanet's and other software offerings.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </appendix>
</book>
