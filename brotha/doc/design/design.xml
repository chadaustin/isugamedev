<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="docbook.css" type="text/css"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>Warn-a-Brotha Design</title>
    <subtitle>Computer Science 309 Spring 2002 Term Project</subtitle>
    <releaseinfo>$Header: /cygdrive/c/Users/Chad/Desktop/SourceForge Backup/isugamedev/cvs/brotha/doc/design/design.xml,v 1.55 2002-04-11 08:34:15 aegis Exp $</releaseinfo>
    <pubdate>$Date: 2002-04-11 08:34:15 $</pubdate>
    <authorgroup>
      <author>
        <firstname>Chad</firstname>
        <surname>Austin</surname>
      </author>
      <author>
        <firstname>Josh</firstname>
        <surname>Carlson</surname>
      </author>
      <author>
        <firstname>Jeremy</firstname>
        <surname>Hanson</surname>
      </author>
      <author>
        <firstname>Chad</firstname>
        <surname>Okere</surname>
      </author>
      <author>
        <firstname>Ben</firstname>
        <surname>Scott</surname>
      </author>
    </authorgroup>
    <address><email>isugamedev-brotha@lists.sourceforge.net</email></address>
    <revhistory>
      <revision>
        <revnumber>1.1</revnumber>
        <date>03 Apr 2002</date>
        <revremark>Created document skeleton.</revremark>
      </revision>
    </revhistory>
  </bookinfo>
  <preface>
    <title>Introduction</title>
    <para><emphasis>Warn-a-Brotha</emphasis> is an online 3D racing game in the spirit of <emphasis>Mario Kart</emphasis> and <emphasis>F-Zero</emphasis>. The game will feature cartoon characters in a multi-player battle cart racing game. Players will be able to compete in combat and racing action against several other networked friends.</para>
    <para>The game will include power-ups, damage meters and an interesting interface. We plan on keeping track of player and gang-related statistics and preferences such as the number of kills they've made, number of times they've died and the number of cars they've trashed. The player will be able to choose one of several characters, each with his or her own look and attitude.</para>
    <para>The <emphasis>Warn-a-Brotha</emphasis> client program will be implemented using OpenGL and C++ while the server will be implemented with portable C++. The clients and server will communicate over the TCP/IP layer. Due to time constraints, we will assume that all computers are on a LAN or other suitably fast connection so that we can generally ignore the lag problems associated with dial-up networked play.</para>
    <para>The underlying database will be implemented using XML tables storing gangs, players, cars and car modifications where each gang can have multiple players, each player can have multiple cars and each car can have multiple modifications.</para>
  </preface>
  <chapter>
    <title>Modules</title>
    <para>At a high level, <emphasis>Warn-a-Brotha</emphasis> can be broken down into several clear modules. This includes Connection Manager, Data/XML, Game Logic, Input, Network, Report Server, Sound, Texture, Threading and UI.</para>
    <section>
      <title>Connection Manager Module</title>
      <para>The Connection Manager module is responsible for handling the sending and receiving of messages from a number of peer connections. Objects of type <classname>Socket</classname> are passed into the module through the <methodname>handleSocket</methodname> method. This method returns a unique connection identification number that will be associated with the <classname>Socket</classname> object. The <methodname>send</methodname> method accepts an object of type <classname>Message</classname> and a connection identification number. The message that is passed in will be sent to the peer connection represented by the connection identification number. The <methodname>readAll</methodname> method will return to the caller a collection of objects of type <classname>Message</classname> and the connection identification number that represents the peer connection from which the <classname>Message</classname> object originated from. The <classname>Message</classname> class provides the abstract implementation for all <classname>Message</classname> objects. Data cannot be sent using the Connection Manager unless the data is represented by an object that implements the <classname>Message</classname> class.</para>
      <para>Internally the Connection Manager module is composed of several classes: <classname>Connection</classname>, <classname>WriteThread</classname> and <classname>ReadThread</classname><classname></classname>. Each <classname>Socket</classname> passed into the module through <methodname>handleSocket</methodname> creates a <classname>Connection</classname> object. This <classname>Connection</classname> object creates a <classname>WriteThread</classname> and a <classname>ReadThread</classname> to handle the actual sending and receiving of data.</para>
      <para>The Connection Manager module depends on the Network module for the actual sending and receiving of bytes across the network, and the Threading module to allow multiple connections, while keeping these connections seperate from the other connections.</para>
      <section>
        <title>Module Interfaces</title>
        <classsynopsis>
          <ooclass>
            <classname>ConnectionManager</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>handleSocket</methodname>
            <methodparam>
              <type>Socket*</type>
              <parameter>sock</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>send</methodname>
            <methodparam>
              <type>Message*</type>
              <parameter>message</parameter>
            </methodparam>
            <methodparam>
              <type>ConnectionID</type>
              <parameter>connID</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>vector&lt;pair&lt;Message*,ConnectionID&gt; &gt; </type>
            <methodname>readAll</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which method of handling multiple connections should be use?</para>
            </question>
            <answer>
              <para>The Connection Manager module needs the ability of sending and receiving many messages from possibly many connections every frame of the game. The Connection Manager must also gaurantee delivery of every message and that it will be handled in as little time as possible. There are a couple of methods generally used to handle this situation.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>Threads</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Easy to implement.</para>
                          </listitem>
                          <listitem>
                            <para>Scheduling CPU time for each connection is handled by the operating system.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Doesn't scale well past a few thousand connections.</para>
                          </listitem>
                          <listitem>
                            <para>Added overhead for context switching between threads and the use of mutexes.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2 - <emphasis>select() or poll()</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Reduced overhead for handling multiple connections, no context switches or need for mutexes.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>More difficult to implement, have to use asynchronous I/O.</para>
                          </listitem>
                          <listitem>
                            <para>Doesn't scale well past a thousand connections.</para>
                          </listitem>
                          <listitem>
                            <para>Must programatically make sure a specific connection doesn't hog the CPU time, as select() and poll() scan connections linearly.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>We decided to choose the threading model because of its ease of implementation, its complete seperation of connections from each other and because we wanted to use the operating system for scheduling of connections' processor usage.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
    <section>
      <title>Data/XML Module</title>
      <para><classname></classname><classname></classname>The Data/XML module provides access to a persistent, data structure that stores game related data such as cars and players and gangs. One root node <classname>BrothaData</classname>, is used to hold all the data. <classname>BrothaData</classname> provides a method to load and save the data, as well as a convenience function to validate a player based on their password. <classname>BrothaData</classname> also exposes a collection of <classname>Gang</classname> objects, and a collection of <classname>Gang</classname> and <classname>CarType</classname> objects. The <classname>CarType</classname> objects store basic information on a "type" of car, the gangs, basically have a name and a collection of <classname>Player</classname> objects, which in turn hold a name, password and a collection of <classname>Car</classname> objects. Each car has an associated type (from <classname>CarTypes</classname> in the root <classname>BrothaData</classname> node) as well as a collection of <classname>Mod</classname>s. Mods have a "type" and "level" of modification.</para>
      <section>
        <title>Module Interfaces</title>
        <classsynopsis>
          <ooclass>
            <classname>Gang</classname>
          </ooclass>
          <fieldsynopsis>
            <type>string</type>
            <varname>name</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>collection&lt;Player&gt;</type>
            <varname>players</varname>
          </fieldsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Player</classname>
          </ooclass>
          <fieldsynopsis>
            <type>string</type>
            <varname>name</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>string</type>
            <varname>password</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>collection&lt;Car&gt;</type>
            <varname>cars</varname>
          </fieldsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>CarType</classname>
          </ooclass>
          <fieldsynopsis>
            <type>string</type>
            <varname>modelFile</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>string</type>
            <varname>name</varname>
          </fieldsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Car</classname>
          </ooclass>
          <fieldsynopsis>
            <type>CarType</type>
            <varname>carType</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>collection&lt;Mod&gt;</type>
            <varname>mods</varname>
          </fieldsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>ModType</classname>
          </ooclass>
          <fieldsynopsis>
            <type>string</type>
            <varname>name</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>string</type>
            <varname>mountPoint</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>float</type>
            <varname>amount</varname>
          </fieldsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Mod</classname>
          </ooclass>
          <fieldsynopsis>
            <type>ModType</type>
            <varname>modType</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>int</type>
            <varname>level</varname>
          </fieldsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>BrothaData</classname>
          </ooclass>
          <fieldsynopsis>
            <type>collection&lt;Gang&gt;</type>
            <varname>gangs</varname>
          </fieldsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>bool</type>
            <methodname>validatePlayer</methodname>
            <methodparam>
              <type>string</type>
              <parameter>player</parameter>
            </methodparam>
            <methodparam>
              <type>string</type>
              <parameter>password</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <modifier>static</modifier>
            <type>BrothaData</type>
            <methodname>load</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
            <exceptionname>DataException</exceptionname>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>void</type>
            <methodname>save</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
            <exceptionname>DataException</exceptionname>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <para>The BrothaData object needed to be able to store all the information persistantly. Do do that, we decided to use XML and an off the shelf parser. We also decided to use one that supported Xpath and XSL for the report server.</para>
        <section>
          <title>Loading</title>
          <para>One thing we decided to do was to load all the data into memory and create simple wrapper classes around it, rather then using something like SAX and only loading data on demand (and creating wrapper collections and the like). This was done to save time, especially since it won't really end up holding all that much data.</para>
        </section>
      </section>
    </section>
    <section>
      <title>Game Logic Module</title>
      <para>The Game Logic module is responsible for updating the game based on the time passed. It also handles the physics and updates each of the clients information. The Game Logic module manages game specific interactions between object in the world such as cars, buildings and projectile. </para>
      <para>This module supports many different objects that exist in the game. Vehicles are allowed to interact with other vehicles by colliding with them or shooting ammuntion at the enemy. When this happens, a vehicle takes on damage and loses health. Both cars lose health in the event of a collision, but only the vehicle that gets shot loses health in the event of a shooting. When a player loses health, coins are dropped onto the map where the damage occured. These coins can be collected by other players by colliding with them. Coins can be used later in order to purchase modifications to the players vehicle. </para>
      <para>Players also interact with inanimate objects such as buildings and walls. When a collision occurs with a building or wall, health is lost and coins are dropped much in the same way as interactions between players except that buildings and wall do not take on damage.When a players health is equal to zero, that player is dead and must be sent back to the garage. The player is allowed back into the game after purchasing repairs for the vehicle. </para>
      <para>The Game Logic Module depends on the Connection Manager and specified data in order to send messages in order to update player information.</para>
      <section>
        <title>Subsystem 1</title>
        <para>Description of Subsystem 1</para>
      </section>
      <section>
        <title>Subsystem 2</title>
        <para>Description of Subsystem 2</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <classsynopsis>
          <ooclass>
            <classname>GameLogic</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>addPlayer</methodname>
            <methodparam>
              <type>Player*</type>
              <parameter>player</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>removePlayer</methodname>
            <methodparam>
              <type>Player*</type>
              <parameter>player</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>addObject</methodname>
            <methodparam>
              <type>Object*</type>
              <parameter>object</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>removeObject</methodname>
            <methodparam>
              <type>Object*</type>
              <parameter>object</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>update</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Object</classname>
          </ooclass>
          <fieldsynopsis>
            <type>Vec3f</type>
            <varname>position</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>Vec3f</type>
            <varname>velocity</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>float</type>
            <varname>health</varname>
          </fieldsynopsis>
          <fieldsynopsis>
            <type>float</type>
            <varname>maxHealth</varname>
          </fieldsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <para>blah blah</para>
        <section>
          <title>Issue 1</title>
          <para>blah</para>
        </section>
        <section>
          <title>Issue 2</title>
          <para>blah</para>
        </section>
      </section>
    </section>
    <section>
      <title>Input Module</title>
      <para>The Client Input module is responsible for the retrieval of input from the devices. Since the application must run at an approximately consistent frame-rate, the input is polled once every frame by the application. For this module, we will rely on a COTS library suitable for our application.</para>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which COTS input library should we use?</para>
            </question>
            <answer>
              <para>There are many libraries available to manage input in a platform-neutral way.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>GLUT</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Easy to use, straightforward API.</para>
                          </listitem>
                          <listitem>
                            <para>Platform-neutral.</para>
                          </listitem>
                          <listitem>
                            <para>Very simple and straightforward API.</para>
                          </listitem>
                          <listitem>
                            <para>Mature and stable library.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Closed source.</para>
                          </listitem>
                          <listitem>
                            <para>Doesn't easily support device polling.</para>
                          </listitem>
                          <listitem>
                            <para>Not object-oriented.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2 - <emphasis>GameKernel</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Developed by a member of the Brotha team.</para>
                          </listitem>
                          <listitem>
                            <para>Extremely simple object-oriented API.</para>
                          </listitem>
                          <listitem>
                            <para>Open source.</para>
                          </listitem>
                          <listitem>
                            <para>Platform-neutral.</para>
                          </listitem>
                          <listitem>
                            <para>Supports runtime keybinding to application specific commands.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Interface is not completely stable.</para>
                          </listitem>
                          <listitem>
                            <para>Doesn't yet support input ordering semantics.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>We chose GameKernel for a couple reasons. First, the members of the team are more familiar with it than GLUT. Additionally, it handles keybinding for us as well as having a superior API to GLUT. Also, since GameKernel is open source, we can update it to include any functionality we may need.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
    <section>
      <title>Network Module</title>
      <para>The network module is responsible for creating sockets and server sockets. It also provides stream classes which simplify access to stream-like objects such as network connections and files. It is built on top of NSPR, a portable system abstraction library provided by mozilla.org.</para>
      <section>
        <title>Socket Subsystem</title>
        <para>The socket subsystem consists of two classes: <classname>Socket</classname> and <classname>ServerSocket</classname>. <classname>ServerSocket</classname> listens on a network port and returns new <classname>Socket</classname> objects when connections are made. <classname>Socket</classname> objects provide methods for reading from, writing to, and closing the socket.</para>
        <para>Sockets also have associated <classname>SocketInputStream</classname> and <classname>SocketOutputStream</classname> objects. See the Stream Subsystem documentation for more details.</para>
      </section>
      <section>
        <title>Stream Subsystem</title>
        <para>The stream subsystem provides objects that represent streams of bytes. Specifically, streams are split into two concepts: InputStreams and OutputStreams. InputStreams have a single <methodname>read</methodname> method and OutputStreams have a single <methodname>write</methodname> method. For example, Sockets have associated <classname>InputStream</classname> and <classname>OutputStream</classname> objects which facilitate reading from and writing to the network connection. The <classname>ByteBuffer</classname> class implements both <classname>InputStream</classname> and <classname>OutputStream</classname> and represents a growable array of bytes.</para>
      </section>
      <section>
        <title>Serialization Subsystem</title>
        <para>The serialization aspect of the network module is responsible for converting objects into streams of bytes and reconstructing the original objects from the stored bytes. It provides a set of operator overloads (mimicking standard C++ iostreams) which simplify writing objects to and reading objects from OutputStreams and InputStreams, respectively.</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <classsynopsis>
          <ooclass>
            <classname>Socket</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <methodname>Socket</methodname>
            <methodparam>
              <type>string</type>
              <parameter>hostname</parameter>
            </methodparam>
            <methodparam>
              <type>int</type>
              <parameter>port</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>int</type>
            <methodname>write</methodname>
            <methodparam>
              <modifier>const</modifier>
              <type>void*</type>
              <parameter>buffer</parameter>
            </methodparam>
            <methodparam>
              <type>int</type>
              <parameter>size</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>read</methodname>
            <methodparam>
              <type>void*</type>
              <parameter>buffer</parameter>
            </methodparam>
            <methodparam>
              <type>int</type>
              <parameter>size</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>close</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>InputStream</type>
            <methodname>getInputStream</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>OutputStream</type>
            <methodname>getOutputStream</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>ServerSocket</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <methodname>ServerSocket</methodname>
            <methodparam>
              <type>int</type>
              <parameter>port</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>Socket</type>
            <methodname>accept</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>InputStream</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>read</methodname>
            <methodparam>
              <modifier>const</modifier>
              <type>void*</type>
              <parameter>buffer</parameter>
            </methodparam>
            <methodparam>
              <type>int</type>
              <parameter>size</parameter>
            </methodparam>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>OutputStream</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>write</methodname>
            <methodparam>
              <type>void*</type>
              <parameter>buffer</parameter>
            </methodparam>
            <methodparam>
              <type>int</type>
              <parameter>size</parameter>
            </methodparam>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>ByteBuffer implements InputStream, OutputStream</classname>
          </ooclass>
        </classsynopsis>
        <para></para>
        <para>template&lt;typename T&gt; OutputStream&amp; operator&lt;&lt;(OutputStream&amp; os, T value);</para>
        <para>template&lt;typename T&gt; InputStream&amp; operator&gt;&gt;(InputStream&amp; os, T&amp; value);</para>
      </section>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Should socket reads and writes be synchronous or asynchronous?</para>
            </question>
            <answer>
              <para>Networking code is often the hardest to design in nontrivial systems. One decision we had to make was whether socket reads and writes were blocking or nonblocking. Blocking socket calls do not return until the I/O operation has completed. Nonblocking calls simply do as much as work as they can and return the number of bytes they read or wrote.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>Synchronous (Blocking) I/O</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Easy to implement and understand.</para>
                          </listitem>
                          <listitem>
                            <para>Less network latency because the waiting thread is woken by the operating system when the I/O operation completes.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Requires threads for interactive applications.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2 - <emphasis>Asynchronous (Nonblocking) I/O</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Does not require threading or involve synchronization issues.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Requires a lot of complex code (involving many loops and state machines) for conceptually simple operations.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>Since blocking I/O is so much simpler to use than nonblocking I/O, we chose to use it for all game message passing. However, since blocking I/O requires knowing how much data you need to read or write at a time, we cannot use it for the http server. Therefore, the socket objects will also support a nonblocking mode.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
    <section>
      <title>Report Server Module</title>
      <para>The Report Server module is responsible for generating dynamic reports requested by HTTP 1.0 standards complient clients. The reports will be generated based on data gathered from the Data/XML module. These reports will be formatted to comply with the specifications for the HyperText Markup Language. This module depends on the Data/XML module for the gathering of data and the Network module for the use of a <classname>ServerSocket</classname> to accept sockets and a <classname>Socket</classname> for the transmitting of data.</para>
      <section>
        <title>Module Interfaces</title>
        <classsynopsis>
          <ooclass>
            <classname>ReportServer</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>bool</type>
            <methodname>stop</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>stop</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which method of formatting data should be used?</para>
            </question>
            <answer>
              <para>The Report Server moduel will need the ability to generate dynamic reports based on subsets of the XML data. Since each report may not include all the information, we'll need a method to specify this.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>Web based scripting (Perl, ASP, PHP)</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Easy to generate dynamic output.</para>
                          </listitem>
                          <listitem>
                            <para>Efficient use of bandwidth as the data is limitted on the server.</para>
                          </listitem>
                          <listitem>
                            <para>Most clients already have applications capable of viewing the output.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Requires external interpreter for the chosen language.</para>
                          </listitem>
                          <listitem>
                            <para>Formatting the data is a tedious process.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2 - <emphasis>XML and XSL and XPath</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Easy to generate dynamic content.</para>
                          </listitem>
                          <listitem>
                            <para>Formatting data simply requires a style sheet.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Inefficient use of bandwidth as data is limitted on the client.</para>
                          </listitem>
                          <listitem>
                            <para>Requires client to have an application capable of using this technology.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>We decided to choose the XML, XSL, and XPath method. We chose this method because of the lack of need to write custom routines to generate the HTML. We will also be able to gaurantee that the client has the appropriate software, so that isn't an issue.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
    <section>
      <title>Sound Module</title>
      <para>The sound module is responsible for managing background music and sound effects within the game. Brotha uses <emphasis>Audiere</emphasis>, an external audio library independently developed by Chad Austin, for reading and playing streams of audio. The sound module consists of two subsystems: the background music <classname>Jukebox</classname> object and the <classname>SoundEffectManager</classname> object.</para>
      <section>
        <title>Jukebox Subsystem</title>
        <para>The <classname>Jukebox</classname> is responsible for maintaining a list of background music <classname>Track</classname>s. It provides functionality for adding <classname>Track</classname>s, removing <classname>Track</classname>s, starting playback, stopping or pausing playback and changing the background music volume. It also provides functionality for getting the current track name and how long it has been playing. Since Audiere files are streamed from disk, the <classname>Jukebox</classname> does not have to load entire songs into memory.</para>
      </section>
      <section>
        <title>Sound Effect Manager Subsystem</title>
        <para>The sound effect manager is responsible for playing sound effects, which are referred to by name. The <classname>SoundEffectManager</classname> has one method, <methodname>trigger</methodname>, which loads a sound effect if it hasn't already been loaded and plays it at a specified volume. Since sound effects can be played often and at unpredictable times, the sound effect manager should keep them in memory to prevent unpredictable latency.</para>
      </section>
      <section>
        <title>Module Interfaces</title>
        <figure>
          <title>Sound Module Interface Specification</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="figures/sound_classes.png" format="PNG" scalefit="1"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>The interface for the Sound module consists of the <classname>Jukebox</classname> and <classname>SoundEffectManager</classname> classes.</para>
        <classsynopsis>
          <ooclass>
            <classname>Jukebox</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>addTrack</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>removeTrack</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>unsigned int</type>
            <methodname>getNumTracks</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>start</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>stop</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>SoundEffectManager</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>trigger</methodname>
            <methodparam>
              <type>string</type>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which COTS audio library should we use?</para>
            </question>
            <answer>
              <para>From the outside, the sound module directly satisfies the audio needs of the application. However, it can be implemented using one of several audio decoding and playback libraries.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>Audiere</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Open source.</para>
                          </listitem>
                          <listitem>
                            <para>Developed by a member of the Brotha team.</para>
                          </listitem>
                          <listitem>
                            <para>Very simple and straightforward API.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Not as mature as some other libraries.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2 - <emphasis>FMOD</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Mature and stable library</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Needlessly complex API</para>
                          </listitem>
                          <listitem>
                            <para>Closed source</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>We chose Audiere for a couple reasons. The members of the team are more familiar with it than FMOD. Since Audiere is open source, we can update it to include any functionality we need.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
    <section>
      <title>Texture Module</title>
      <para>The texture module is responsible for loading image files from the disk and creating OpenGL texture objects out of them. It uses the third-party <emphasis>Corona</emphasis> image library (externally developed by Chad Austin). The texture module has two object types: one <classname>TextureManager</classname> and several <classname>Texture</classname> objects.</para>
      <para>The <classname>TextureManager</classname>, given the name of a <classname>Texture</classname>, will load the texture from disk, possibly process the image until it is in a format suitable for OpenGL, and create a new <classname>Texture</classname> object representing that texture. The <classname>TextureManager</classname> remembers and caches loaded textures so that it never loads a texture twice. </para>
      <para><classname>Texture</classname> objects provide a <methodname>bind</methodname> method which calls <methodname>glBindTexture</methodname>, changing OpenGL's current texture. It also provides a mechanism for changing texture parameters, such as whether to use <constant>NEAREST</constant> or <constant>LINEAR</constant> texel interpolation.</para>
      <section>
        <title>Module Interfaces</title>
        <classsynopsis>
          <ooclass>
            <classname>TextureManager</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>Texture</type>
            <methodname>getTexture</methodname>
            <methodparam>
              <type>string</type>
              <parameter>name</parameter>
            </methodparam>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Texture</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>void</type>
            <methodname>setParameter</methodname>
            <methodparam>
              <type>string</type>
              <parameter>parameter</parameter>
            </methodparam>
            <methodparam>
              <type>string</type>
              <parameter>value</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <type>void</type>
            <methodname>bind</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which COTS image library should we use?</para>
            </question>
            <answer>
              <para>Like the sound module, the texture module sits on top of low-level libraries and provides a convenient mechanism for accessing textures within the context of the Warn-a-Brotha game. Since the interface to the module is so general, it can be implemented internally in many different ways.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>Corona</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Portable.</para>
                          </listitem>
                          <listitem>
                            <para>Very easy to install and use.</para>
                          </listitem>
                          <listitem>
                            <para>Developed by a member of the team.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Not as mature as some external libraries.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2 - <emphasis>Other Image Libraries</emphasis> (e.g. FreeImage, DevIL, SDL_Image)</title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>APIs are usually stable.</para>
                          </listitem>
                          <listitem>
                            <para>More widely used.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Often not portable.</para>
                          </listitem>
                          <listitem>
                            <para>Difficult to install and use.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>Because Corona is easier to use and the developers are more familiar with it, we chose to implement the texture subsystem on top of it. We don't plan to use file formats that Corona does not support.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
    <section>
      <title>Thread Module</title>
      <para>The thread module provides a suite of utility classes for creating threads and synchronizing them. It is built on top of NSPR (Netscape Portable Runtime) which is a portable system abstraction layer for C provided by mozilla.org. It consists of several classes: a base <classname>Thread</classname> class, a <classname>Lockable</classname> interface, a <classname>Mutex</classname> implementation of the <classname>Lockable</classname> interface, a <classname>ConditionVariable</classname> class, and a <classname>Synchronized</classname> mix-in class which provides functionality similar to Java's synchronized method semantics.</para>
      <para>The thread, mutex, and lock classes are modeled after boost.org's boost.Threads thread model and the multithreaded framework described in Modern C++ Design. The Lock object takes and locks a Lockable object on construction. On destruction, the Lock unlocks its Lockable object. This allows for code that is exception-safe and easy to follow. The Lockable object is guaranteed to be unlocked whenever the Lock's scope is exited.</para>
      <para>The Synchronized class is designed so that classes in C++ can mimic the 'synchronized' attribute of Java. Simply derive a class from Synchronized and instantiate a Lock object at the beginning of each method, passing 'this' as the Lockable.</para>
      <section>
        <title>Module Interfaces</title>
        <classsynopsis>
          <ooclass>
            <classname>Thread</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>start</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <modifier>abstract</modifier>
            <void/>
            <methodname>run</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Lockable</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>lock</methodname>
            <void/>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <void/>
            <methodname>unlock</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Mutex implements Lockable</classname>
          </ooclass>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Synchronized implements Lockable</classname>
          </ooclass>
        </classsynopsis>
        <classsynopsis>
          <ooclass>
            <classname>Lock</classname>
          </ooclass>
          <methodsynopsis>
            <modifier>public</modifier>
            <methodname>Lock</methodname>
            <methodparam>
              <type>Lockable*</type>
              <parameter>lock</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
            <modifier>public</modifier>
            <methodname>~Lock</methodname>
            <void/>
          </methodsynopsis>
        </classsynopsis>
      </section>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which COTS threading library should we use?</para>
            </question>
            <answer>
              <para>We did not want to develop, maintain, debug, and test our own threading library implementation. We had three major choices: NSPR, Common C++, and Vapor.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>NSPR</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Highly portable.</para>
                          </listitem>
                          <listitem>
                            <para>Well-tested.</para>
                          </listitem>
                          <listitem>
                            <para>Used in much software.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist>
                          <listitem>
                            <para>Low-level.</para>
                          </listitem>
                        </itemizedlist>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>C-based API.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2 - <emphasis>Common C++</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>C++ API.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Did not appear mature.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2 - <emphasis>Vapor</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>C++ API.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Since Vapor is built on top of NSPR, it is more complex.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>We decided on using NSPR, as it is well-tested, portable to many platforms, documented well, and very mature.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
    <section>
      <title>UI Module</title>
      <para>The UI module is responsible for the creation and management of GUI widget elements such as windows, buttons and such. For this module, we will rely on a COTS library suitable for our application.</para>
      <section>
        <title>Design Issues</title>
        <qandaset>
          <qandaentry>
            <question>
              <para>Which COTS library should we use for the GUI implementation?</para>
            </question>
            <answer>
              <para>The client application is being developed using OpenGL. As such normal Win32 controls may not be used within the windows with the OpenGL rendering context. We need to depend on some external library that can render controls within using OpenGL commands.</para>
              <formalpara>
                <title>Alternative 1 - <emphasis>GLUI</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Easy to use.</para>
                          </listitem>
                          <listitem>
                            <para>It's been around a while and is relatively mature.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Won't integrate well with <emphasis>GameKernel</emphasis>.</para>
                          </listitem>
                          <listitem>
                            <para>Difficult to create controls in the master window. Often times, a separate window is required to put the control in.</para>
                          </listitem>
                          <listitem>
                            <para>Control rendering is not customizable.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Alternative 2- <emphasis>phui</emphasis></title>
                <para><variablelist>
                    <varlistentry>
                      <term>Pros</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Easy to use.</para>
                          </listitem>
                          <listitem>
                            <para>Allows customization of the rendering of controls.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>Cons</term>
                      <listitem>
                        <itemizedlist spacing="compact">
                          <listitem>
                            <para>Is not mature or stable.</para>
                          </listitem>
                          <listitem>
                            <para>May integrate with <emphasis>GameKernel</emphasis> to some limited extent.</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist></para>
              </formalpara>
              <formalpara>
                <title>Conclusion</title>
                <para>We're stuck with <emphasis>GameKernel</emphasis> to provide our applications input. Thus the choice clearly points towards using <emphasis>phui</emphasis>. We have to gamble that phui developers can make it stable in the next couple of weeks.</para>
              </formalpara>
            </answer>
          </qandaentry>
        </qandaset>
      </section>
    </section>
  </chapter>
  <chapter>
    <title>Putting It All Together</title>
    <para>Since <emphasis>Warn-a-Brotha</emphasis> has an overall client/server design, the project can be split into two distinctly seperate applications that use the modules differently.</para>
    <section>
      <title>The Server Application</title>
      <figure>
        <title>Components used by the Server Application</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="figures/server_components.png" format="PNG" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The server is the main workhorse, responsible for managing multiple client connections and their requests, updating the state of the game on a regular basis and sending messages to connected clients with the updates on the state of the game. The server is also responsible for storing gang, player, car, and car modification specific information, providing this information to the clients, and generating reports on this information.</para>
    </section>
    <section>
      <title>The Client Application</title>
      <figure>
        <title>Components Used by the Client Application</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="figures/client_components.png" format="PNG" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The client application is simply the glue that binds the various modules it requires - namely Connection Manager, Input, Sound, Texture and UI. It is really just a dumb display which allows the user to connect to the server. Once connected, it processes input from the attached and configured devices and which device inputs are triggered, forwards the corresponding request to the server. The client also provides a visual view onto the game world based on the update data received from the server.</para>
    </section>
  </chapter>
  <chapter>
    <title>Traceability Matrix</title>
    <para>probably figure out how to create a table or else stuff a pic in here</para>
  </chapter>
  <appendix>
    <title>External Dependencies</title>
    <variablelist>
      <varlistentry>
        <term><emphasis>Audiere</emphasis></term>
        <listitem>
          <para>Audiere is a high-level audio API, somewhat analogous to FMOD. Built on top of Acoustique, it supports MP3, Ogg Vorbis, uncompressed WAV, IT, XM, S3M and MOD. It can use DirectSound 8, DirectSound 3 or arbitrary DLLs for audio output. In Linux, it can use OSS or OpenAL. At the moment, Audiere only works under Win32 and Linux. It is licensed under the LGPL.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>Corona</emphasis></term>
        <listitem>
          <para>Corona is a high-level, portable I/O library usable from C++. It can read PNG, JPEG, PCX and BMP images, and can write PNGs. It's licensed under the zlib license.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>Game Kernel</emphasis></term>
        <listitem>
          <para>GameKernel is a flexible, open-source platform for running games being developed by members of the Iowa State University Game Developers Club. Designed with pluggable DLL drivers, GameKernel can currently operate using GLUT or SDL. It is supported on Windows, Linux and IRIX. Game Kernel is licensed under the LGPL.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>phui</emphasis></term>
        <listitem>
          <para>Phui is a "phlexible user interface" for OpenGL based applications. Developed by members of the Game Developers Club at IowaState University, phui is designed to allow for the large amount of control in the rendering of widgets that game developers demand.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>NSPR</emphasis></term>
        <listitem>
          <para>Netscape Portable Runtime (NSPR) provides a platform-neutral API for system level and libc like functions. The API is used in the Mozilla client, many of Netscape/AOL/iPlanet's and other software offerings.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </appendix>
</book>
